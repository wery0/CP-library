struct fraction {
    ll num = 0;
    ll den = 1;

    void normalize() {
        if (den < 0) den *= -1, num *= -1;
        ll gc = num == 0 ? 1 : __gcd(abs(num), den);
        num /= gc;
        den /= gc;
    }

    fraction() {}

    fraction(ll a) {
        num = a;
    }

    fraction(ll a, ll b) {
        num = a;
        den = b;
        normalize();
    }

    bool is_integer() const {
        return den == 1;
    }

    fraction operator-() const {
        return {-num, den};
    }

    fraction operator+(const fraction &other) const {
        return {num * other.den + other.num * den, den * other.den};
    }

    void operator+=(const fraction &other) {
        num = num * other.den + other.num * den;
        den *= other.den;
    }

    fraction operator-(const fraction &other) const {
        return {num * other.den - other.num * den, den * other.den};
    }

    void operator-=(const fraction &other) {
        num = num * other.den - other.num * den;
        den *= other.den;
    }

    fraction operator*(const fraction &other) const {
        return {num * other.num, den * other.den};
    }

    void operator*=(const fraction &other) {
        num *= other.num;
        den *= other.den;
    }

    fraction operator/(const fraction &other) const {
        assert(other.num != 0);
        return {num * other.den, den * other.num};
    }

    void operator/=(const fraction &other) {
        assert(other.num != 0);
        num *= other.den;
        den *= other.num;
    }

    bool operator!=(const fraction &other) const {
        return num * other.den != other.num * den;
    }

    bool operator==(const fraction &other) const {
        return num * other.den == other.num * den;
    }

    bool operator<(const fraction &other) const {
        return num * other.den < other.num * den;
    }

    bool operator>(const fraction &other) const {
        return num * other.den > other.num * den;
    }

    friend ostream &operator<<(ostream &os, const fraction &fr) {
        if (fr.den == 1) return os << fr.num;
        return os << "\\frac{" << fr.num << "}{" << fr.den << "}";
    }

    friend fraction abs(const fraction &f) {
        return f > 0 ? f : -f;
    }

    friend ll gcd_of_numenators(const fraction &f1, const fraction &f2) {
        return __gcd(abs(f1.num), abs(f2.num));
    }

    friend fraction lcm_of_numenators(const fraction &f1, const fraction &f2) {
        if (f1 == 0 || f2 == 0) return abs(f1 + f2);
        ll gc = gcd_of_numenators(f1, f2);
        return fraction(abs(f1.num) / gc * abs(f2.num));
    }

    friend fraction inv(const fraction &f) {
        return {f.den, f.num};
    }

    friend int sign(const fraction &f) {
        return f.num < 0 ? -1 : f.num == 0 ? 0 : 1;
    }
};