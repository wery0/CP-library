const ld EPS = 1e-9;
const ld PI = 3.1415926535897932384626433832;

struct pt {
    ld x = 0, y = 0;

    pt() {}

    pt(ld a, ld b) {
        x = a, y = b;
    }

    pt operator+(const pt &p) { return {x + p.x, y + p.y}; }

    pt operator-(const pt &p) { return {x - p.x, y - p.y}; }

    pt operator*(const ld c) { return {x * c, y * c}; }

    pt operator/(const ld c) { return {x / c, y / c}; }

    void operator+=(const pt &p) { x += p.x, y += p.y; }

    void operator-=(const pt &p) { x -= p.x, y -= p.y; }

    void operator*=(const ld c) { x *= c, y *= c; }

    void operator/=(const ld c) { x /= c, y /= c; }

    bool operator==(const pt &p) const {return p.x == x && p.y == y;}

    bool operator!=(const pt &p) const {return p.x != x || p.y != y;}

    ld dst(const pt &p) { return sqrtl((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y)); }

    ld dot(const pt &p) { return x * p.x + y * p.y; }

    ld cross(const pt &p) { return x * p.y - y * p.x; }

    pt normalize() {
        if (abs(x) < EPS && abs(y) < EPS) assert(0);
        ld c = sqrtl(x * x + y * y);
        x /= c;
        y /= c;
        return pt(x, y);
    }

    void print(str lst = "\n") {
        cout << "{" << x << ", " << y << "}" << lst;
    }
};

struct line {
    ld A, B, C;

    ld dst_pt(pt &p) {
        normalize();
        return abs(A * p.x + B * p.y + C);
    }

    line(ld AA, ld BB, ld CC) {
        A = AA;
        B = BB;
        C = CC;
        normalize();
    }

    line(pt a, pt b) {
        A = a.y - b.y;
        B = b.x - a.x;
        C = a.cross(b);
        normalize();
    }

    void printkxb() {
        if (abs(B) < EPS) {
            cout << "X = " << -C / A << endl;
        } else {
            cout << "Y = " << -A / B << "X + " << (-C / B) << endl;
        }
    }

    void printABC() {
        cout << A << " " << B << " " << C << endl;
    }

    void normalize() {
        assert(abs(A) + abs(B) > EPS);
        ld u = sqrtl(A * A + B * B);
        A /= u, B /= u, C /= u;
        if (A < -EPS || (abs(A) < EPS && B < -EPS)) A *= -1, B *= -1, C *= -1;
    }

    line get_normal(pt p) {
        return line(p, p + pt(A, B));
    }

    void make_normal(pt p) {
        pt p2 = p + pt(A, B);
        line nw = line(p, p2);
        A = nw.A;
        B = nw.B;
        C = nw.C;
    }

    pt intersect(const line &l) {
        assert(abs(A - l.A) + abs(B - l.B) > EPS);
        ld x = (l.C * B - C * l.B) / (A * l.B - l.A * B);
        ld y = (l.A * C - A * l.C) / (A * l.B - l.A * B);
        return {x, y};
    }

    int is_parallel(line &l) {
        return abs(l.A - A) + abs(l.B - B) < EPS;
    }

    int is_equal(line &l) {
        return abs(l.A - A) + abs(l.B - B) + abs(l.C - C) < EPS;
    }
};

struct circle {
    pt p;
    ld r;

    circle() {}

    circle(pt a, ld b) {
        p = a;
        r = b;
    }

    vec<pt> line_intersection(line l) {
        ld dst = l.dst_pt(p);
        if (dst > r + EPS) return {};
        pt mid = l.intersect(l.get_normal(p));
        if (abs(dst - r) < EPS) return {mid};
        pt n = { -l.B, l.A};
        ld d = sqrtl(r * r - dst * dst);
        n.normalize();
        return {mid - n * d, mid + n * d};
    }

    vec<pt> circle_intersection(circle c) {
        ld d = c.p.dst(p);
        if (abs(d) < EPS) {
            if (abs(r - c.r) > EPS) return {};
            //process inf points
            assert(0);
            return {};
        }
        pt df = p;
        p -= df, c.p -= df;
        line l = line(-2 * c.p.x, -2 * c.p.y, c.p.dot(c.p) + r * r - c.r * c.r);
        vec<pt> m = line_intersection(l);
        for (pt &P : m) P += df;
        p += df;
        c.p += df;
        return m;
    }

    void tangents(pt c, ld r1, ld r2, vec<line> &ans) {
        ld r = r2 - r1;
        ld z = c.x * c.x + c.y * c.y;
        ld d = z - r * r;
        if (d < -EPS) return;
        d = sqrtl(abs(d));
        ans.pb(line((c.x * r + c.y * d) / z, (c.y * r - c.x * d) / z, r1));
    }

    vec<line> common_tangents (circle b) {
        vec<line> ans;
        for (int i = -1; i <= 1; i += 2)
            for (int j = -1; j <= 1; j += 2)
                tangents (b.p - p, r * i, b.r * j, ans);
        for (line &l : ans) l.C -= l.A * p.x + l.B * p.y;
        vec<line> nw;
        for (line l : ans) {
            int fl = 0;
            for (line u : nw) fl |= u.is_equal(l);
            if (!fl) nw.pb(l);
        }
        return nw;
    }
};

ld calc_len_of_arc(pt c, pt p1, pt p2) {
    ld r = c.dst(p1);
    ld d = p1.dst(p2);
    ld ang = acosl(1 - d * d / (2 * r * r) + EPS);
    return r * ang;
}
 
ld calc_len_of_arc(pt c, pt p1, pt p2) {
    ld r = c.dst(p1);
    ld d = p1.dst(p2);
    ld ang = acosl(1 - d * d / (2 * r * r) + EPS);
    return r * ang;
}