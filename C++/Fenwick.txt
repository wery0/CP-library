template<typename T, int G>
struct fenv {
    vec<T> fen = vec<T>(G);
    //T fen[G] = {0};
    //array<T, G> fen{};

    fenv(vec<T> &n){
        for(int q=1; q<=n.size(); q++){
            fen[q] += n[q-1];
            const int nw = q + (q & -q);
            if (nw < G) fen[nw] += fen[q];
        }
    }

    fenv(T val) {
        for (int q = 1; q < G; q++) {
            fen[q] += val;
            const int nw = q + (q & -q);
            if (nw < G) fen[nw] += fen[q];
        }
    }

    void add(int p, T x) {
	assert(p);
        for (; p < G; p += p & -p) fen[p] += x;
    }

    T pref_sum(int p) {
        T o = 0;
        for (; p; p -= p & -p) o += fen[p];
        return o;
    }

    T sum_lr(int l, int r) {
        return pref_sum(r) - (l ? pref_sum(l - 1) : 0);
    }

    int max_pref_with_sum_leq_k(T k) {
        int p = 0, step = 1 << __lg(G);
        T s = 0;
        for (; step; step >>= 1) {
            int nw = p + step;
            if (nw < G && s + fen[nw] <= k) p = nw, s += fen[nw];
        }
        return p;
    }
};







template<typename T, int G>
struct fenv {
    vec<T> fen = vec<T>(G);
    //T fen[G] = {0};
    //array<T, G> fen{};

    fenv(){}

    fenv(vec<T> &n){
        for(int q=1; q<=n.size(); q++){
            fen[q] += n[q-1];
            const int nw = q + (q & -q);
            if (nw < G) fen[nw] += fen[q];
        }
    }

    fenv(T val) {
        for (int q = 1; q < G; q++) {
            fen[q] += val;
            const int nw = q + (q & -q);
            if (nw < G) fen[nw] += fen[q];
        }
    }

    T sum(int p) {
        T o = 0;
        for (; p < G; p += p & -p) {
            o += fen[p];
        }
        return o;
    }

    void pref_add(int p, T x) {
        for (; p; p -= p & -p) {
            fen[p] += x;
        }
    }

    void add_lr(int l, int r, T x) {
        pref_add(r, x);
        pref_add(l - 1, mod-x);
    }
};