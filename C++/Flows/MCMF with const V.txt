template<typename T_flow, typename T_cost, const int V>
struct min_cost_max_flow {
    struct edge {
        int fr, to;
        T_flow f;
        T_cost c, w;
    };

    int a, ss = V - 2, tt = V - 1;
    vec<int> l[V];
    vec<vec<int>> l;
    vec<edge> e;

    void add_edge(int fr, int to, T_flow c, T_cost w) {
        l[fr].pb(e.size());
        e.pb({fr, to, 0, c, w});
        l[to].pb(e.size());
        e.pb({to, fr, 0, 0, -w});
    }

    vec<T_cost> dst;
    vec<int> pr, inq;
    pair<T_flow, T_cost> calc() {
        const T_cost inf = numeric_limits<T_cost>::max();
        T_flow flow = 0;
        T_cost cost = 0;
        dst.resize(a);
        pr.resize(a);
        inq.resize(a);
        for (;;) {
            fill(all(dst), inf);
            fill(all(pr), -1);
            fill(all(inq), 0);
            dst[ss] = 0;
            inq[ss] = 1;
            deque<int> dq = {ss};
            for (; dq.size();) {
                int v = dq.front(); dq.pop_front();
                inq[v] = 0;
                for (int i : l[v]) {
                    if (e[i].c == e[i].f) continue;
                    T_cost tyt = dst[v] + e[i].w;
                    int to = e[i].to;
                    if (tyt < dst[to]) {
                        dst[to] = tyt;
                        pr[to] = i;
                        if (!inq[to]) {
                            inq[to] = 1;
                            dq.pb(to);
                        }
                    }
                }
            }
            if (dst[tt] == inf) break;
            ++flow;
            cost += dst[tt];
            int v = tt;
            for (; v != ss;) {
                int i = pr[v];
                e[i].f++;
                e[i ^ 1].f--;
                v = e[i].fr;
            }
        }
        return {flow, cost};
    }
};