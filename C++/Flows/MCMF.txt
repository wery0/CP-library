template<typename T>
struct min_cost_max_flow {
    struct edge {
        int fr, to;
        T f, c, w;
    };

    const T inf = numeric_limits<T>::max();
    int a, ss, tt;
    vec<vec<int>> l;
    vec<edge> e;

    min_cost_flow(int _a) {
        a = _a;
        l = vec<vec<int>>(a, vec<int>());
    }

    void add_edge(int fr, int to, T c, T w) {
        l[fr].pb(e.size());
        e.pb({fr, to, 0, c, w});
        l[to].pb(e.size());
        e.pb({to, fr, 0, 0, -w});
    }

    pair<T, T> calc() {
        T flow = 0, cost = 0;
        T dst[a];
        int pr[a], inq[a];
        for (;;) {
            fill(dst, dst + a, inf);
            fill(pr, pr + a, -1);
            fill(inq, inq + a, 0);
            dst[ss] = 0;
            inq[ss] = 1;
            deque<int> dq = {ss};
            for (; dq.size();) {
                int v = dq.front(); dq.pop_front();
                inq[v] = 0;
                for (int i : l[v]) {
                    if (e[i].c == e[i].f) continue;
                    T tyt = dst[v] + e[i].w;
                    int to = e[i].to;
                    if (tyt < dst[to]) {
                        dst[to] = tyt;
                        pr[to] = i;
                        if (!inq[to]) {
                            inq[to] = 1;
                            dq.pb(to);
                        }
                    }
                }
            }
            if (dst[tt] == inf) break;
            ++flow;
            cost += dst[tt];
            int v = tt;
            for (; v != ss;) {
                int i = pr[v];
                e[i].f++;
                e[i ^ 1].f--;
                v = e[i].fr;
            }
        }
        return {flow, cost};
    }
};