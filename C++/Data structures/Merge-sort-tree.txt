template<typename T>
struct merge_sort_tree {
    int G, U;
    vec<vec<T>> store;

    template<typename Iterator>
    merge_sort_tree(Iterator first, Iterator last) {
        U = geq_pow2(last - first);
        G = U * 2;
        store = vec<vec<T>>(G);
        for (auto it = store.begin() + U; first != last; ++first, ++it) {
            *it = {*first};
        }
        for (int q = U; --q; ) {
            merge(all(store[q << 1]), all(store[q << 1 | 1]), back_inserter(store[q]));
        }
    }

    inline int work(vec<T> &arr, T vl, T vr) {
        auto it_r = upper_bound(all(arr), vr);
        auto it_l = lower_bound(all(arr), vl);
        return it_r - it_l;
    }

    int query(int l, int r, T vl, T vr) {   //0 - index
        l += U, r += U;
        int ans = 0;
        while (l <= r) {
            if (l & 1) ans += work(store[l], vl, vr);
            if (~r & 1) ans += work(store[r], vl, vr);
            l = (l + 1) >> 1;
            r = (r - 1) >> 1;
        }
        return ans;
    }
};