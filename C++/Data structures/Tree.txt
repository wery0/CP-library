struct tree {

    void read_tree_as_parents() {
        read_SZ();
        for (int q = 1; q < a; q++) {
            int p; cin >> p;
            l[p].pb(Edge(q));
        }
        ifs(0);
    }

    void read_tree_as_edges_with_weights(int index = 1) {
        read_SZ();
        for (int q = 0; q < a - 1; q++) {
            int x, y; cin >> x >> y; x -= index, y -= index;
            int w; cin >> w;
            l[x].pb(Edge(y, w));
            l[y].pb(Edge(x, w));
        }
        ifs(0);
    }

    void read_tree_as_edges_without_weights(int index = 1) {
        read_SZ();
        for (int q = 0; q < a - 1; q++) {
            int x, y; cin >> x >> y; x -= index, y -= index;
            l[x].pb(Edge(y));
            l[y].pb(Edge(x));
        }
        ifs(0);
    }

    struct Edge {
        int to;
        int len = 0;

        Edge() {}

        Edge(int TO) {
            to = TO;
        }

        Edge(int TO, int D) {
            to = TO;
            len = D;
        }
    };

    int a;
    vec<vec<Edge>> l;
    vec<int> pr;
    vec<int> jump;
    vec<int> dep;
    vec<int> sz;
    vec<int> tin, tout;

    void read_SZ() {
        cin >> a;
        l = vec<vec<Edge>>(a, vec<Edge>());
        pr = vec<int>(a);
        jump = vec<int>(a);
        dep = vec<int>(a);
        sz = vec<int>(a);
        tin = vec<int>(a);
        tout = vec<int>(a);
    }

    void ifs(int v, int p = -1) {
        static int T = 0;
        tin[v] = T++;
        pr[v] = p;
        sz[v] = 1;
        dep[v] = p == -1 ? 0 : dep[p] + 1;
        if (p == -1) jump[v] = v;
        else if (dep[pr[v]] + dep[jump[jump[pr[v]]]] == dep[jump[pr[v]]] * 2) jump[v] = jump[jump[pr[v]]];
        else jump[v] = pr[v];
        for (Edge &e : l[v]) {
            if (e.to == p) continue;
            ifs(e.to, v);
            sz[v] += sz[e.to];
        }
        tout[v] = T;
    }

    int is_descendant(int p, int v) {
        return tin[p] <= tin[v] && tout[v] <= tout[p];
    }

    int kth_ancestor(int v, int k) {
        assert(k <= dep[v]);
        for (; k; ) {
            int u = jump[v], dfd = dep[v] - dep[u];
            if (dfd <= k) v = u, k -= dfd;
            else v = pr[v], k--;
        }
        return v;
    }

    int LCA(int x, int y) {
        if (dep[x] > dep[y]) swap(x, y);
        y = kth_ancestor(y, dep[y] - dep[x]);
        if (x == y) return x;
        for (; pr[x] != pr[y];) {
            int u1 = jump[x], u2 = jump[y];
            if (u1 == u2) x = pr[x], y = pr[y];
            else x = u1, y = u2;
        }
        return pr[x];
    }

int find_centroid(int v) {
    int stv = v, p = -1;
    for (;;) {
        int mxsz = -1, h = -1;
        for (Edge &e : l[v]) {
            if (e.to == p || wasc[e.to]) continue;
            if (chmax(mxsz, sz[e.to])) h = e.to;
        }
        if (mxsz <= sz[stv] / 2) return v;
        p = v, v = h;
    }
    return -1;
}
};